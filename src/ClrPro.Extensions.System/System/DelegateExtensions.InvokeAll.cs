// Copyright (c) ClrCoder community. All Rights Reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.

namespace System
{
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Runtime.CompilerServices;

    /// <content>
    ///     <c>InvokeAll</c> methods implementation.
    /// </content>
    public static partial class DelegateExtensions
    {
        /// <summary>
        ///     Invokes full invocation list of the specified event handler with
        ///     aggregating raised exceptions to the <see cref="AggregateException" />.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Sometimes it's important to execute full invocation list.
        ///     </para>
        /// </remarks>
        /// <param name="eventHandler">The event handler to execute.</param>
        /// <param name="sender">The event sender.</param>
        /// <param name="args">The event arguments.</param>
        /// <param name="isRedirectablePredicate">The predicate to determine Exception that should not be caught and aggregated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [DebuggerStepThrough]
        public static void InvokeAll(
            this EventHandler? eventHandler,
            object? sender,
            EventArgs args,
            Predicate<Exception>? isRedirectablePredicate = null)
        {
            if (args == null)
            {
                throw new ArgumentNullException(nameof(args));
            }

            // ReSharper disable once InvertIf
            if (eventHandler != null)
            {
                List<Exception>? innerExceptions = null;

                // ReSharper disable once PossibleInvalidCastExceptionInForeachLoop
                var invocationList = eventHandler.GetInvocationList();
                var length = invocationList.Length;
                for (var index = 0; index < length; index++)
                {
                    var a = (EventHandler)invocationList[index];
                    try
                    {
                        a(sender, args);
                    }
                    catch (Exception ex) when (isRedirectablePredicate == null || isRedirectablePredicate(ex))
                    {
                        if (innerExceptions == null)
                        {
                            innerExceptions = new List<Exception>();
                        }

                        innerExceptions.Add(ex);
                    }
                }

                if (innerExceptions != null)
                {
                    throw new AggregateException(innerExceptions);
                }
            }
        }

        /// <summary>
        ///     Invokes full invocation list of the specified event handler with
        ///     aggregating raised exceptions to the <see cref="AggregateException" />.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Sometimes it's important to execute full invocation list.
        ///     </para>
        /// </remarks>
        /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
        /// <param name="eventHandler">The event handler to execute.</param>
        /// <param name="sender">The event sender.</param>
        /// <param name="args">The event arguments.</param>
        /// <param name="isRedirectablePredicate">The predicate to determine exception that should not be caught and aggregated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [DebuggerStepThrough]
        public static void InvokeAll<TEventArgs>(
            this EventHandler<TEventArgs>? eventHandler,
            object? sender,
            TEventArgs args,
            Predicate<Exception>? isRedirectablePredicate = null)
        {
            if (args == null)
            {
                throw new ArgumentNullException(nameof(args));
            }

            // ReSharper disable once InvertIf
            if (eventHandler != null)
            {
                List<Exception>? innerExceptions = null;

                // ReSharper disable once PossibleInvalidCastExceptionInForeachLoop
                var invocationList = eventHandler.GetInvocationList();
                var length = invocationList.Length;
                for (var index = 0; index < length; index++)
                {
                    var a = (EventHandler<TEventArgs>)invocationList[index];
                    try
                    {
                        a(sender, args);
                    }
                    catch (Exception ex) when (isRedirectablePredicate == null || isRedirectablePredicate(ex))
                    {
                        if (innerExceptions == null)
                        {
                            innerExceptions = new List<Exception>();
                        }

                        innerExceptions.Add(ex);
                    }
                }

                if (innerExceptions != null)
                {
                    throw new AggregateException(innerExceptions);
                }
            }
        }

        /// <summary>
        ///     Invokes full invocation list of the specified <c>action</c> with
        ///     aggregating raised exceptions to the <see cref="AggregateException" />.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Sometimes it's important to execute full invocation list.
        ///     </para>
        /// </remarks>
        /// <param name="action">The <c>action</c> to execute.</param>
        /// <param name="isRedirectablePredicate">The predicate to determine Exception that should not be caught and aggregated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [DebuggerStepThrough]
        public static void InvokeAll(
            this Action? action,
            Predicate<Exception>? isRedirectablePredicate = null)
        {
            // ReSharper disable once InvertIf
            if (action != null)
            {
                List<Exception>? innerExceptions = null;

                // ReSharper disable once PossibleInvalidCastExceptionInForeachLoop
                var invocationList = action.GetInvocationList();
                var length = invocationList.Length;
                for (var index = 0; index < length; index++)
                {
                    var a = (Action)invocationList[index];
                    try
                    {
                        a();
                    }
                    catch (Exception ex) when (isRedirectablePredicate == null || isRedirectablePredicate(ex))
                    {
                        if (innerExceptions == null)
                        {
                            innerExceptions = new List<Exception>();
                        }

                        innerExceptions.Add(ex);
                    }
                }

                if (innerExceptions != null)
                {
                    throw new AggregateException(innerExceptions);
                }
            }
        }

        /// <summary>
        ///     Invokes full invocation list of the specified <c>action</c> with
        ///     aggregating raised exceptions to the <see cref="AggregateException" />.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Sometimes it's important to execute full invocation list.
        ///     </para>
        /// </remarks>
        /// <typeparam name="T">The type of the <c>action</c> argument.</typeparam>
        /// <param name="action">The <c>action</c> to execute.</param>
        /// <param name="arg">The <c>action</c> argument.</param>
        /// <param name="isRedirectablePredicate">The predicate to determine Exception that should not be caught and aggregated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [DebuggerStepThrough]
        public static void InvokeAll<T>(
            this Action<T>? action,
            T arg,
            Predicate<Exception>? isRedirectablePredicate = null)
        {
            // ReSharper disable once InvertIf
            if (action != null)
            {
                List<Exception>? innerExceptions = null;

                // ReSharper disable once PossibleInvalidCastExceptionInForeachLoop
                var invocationList = action.GetInvocationList();
                var length = invocationList.Length;
                for (var index = 0; index < length; index++)
                {
                    var a = (Action<T>)invocationList[index];
                    try
                    {
                        a(arg);
                    }
                    catch (Exception ex) when (isRedirectablePredicate == null || isRedirectablePredicate(ex))
                    {
                        if (innerExceptions == null)
                        {
                            innerExceptions = new List<Exception>();
                        }

                        innerExceptions.Add(ex);
                    }
                }

                if (innerExceptions != null)
                {
                    throw new AggregateException(innerExceptions);
                }
            }
        }

        /// <summary>
        ///     Invokes full invocation list of the specified <c>action</c> with
        ///     aggregating raised exceptions to the <see cref="AggregateException" />.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Sometimes it's important to execute full invocation list.
        ///     </para>
        /// </remarks>
        /// <typeparam name="T1">The type of the <c>action</c> argument 1.</typeparam>
        /// <typeparam name="T2">The type of the <c>action</c> argument 2.</typeparam>
        /// <param name="action">The <c>action</c> to execute.</param>
        /// <param name="arg1">The <c>action</c> argument 1.</param>
        /// <param name="arg2">The <c>action</c> argument 2.</param>
        /// <param name="isRedirectablePredicate">The predicate to determine Exception that should not be caught and aggregated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [DebuggerStepThrough]
        public static void InvokeAll<T1, T2>(
            this Action<T1, T2>? action,
            T1 arg1,
            T2 arg2,
            Predicate<Exception>? isRedirectablePredicate = null)
        {
            // ReSharper disable once InvertIf
            if (action != null)
            {
                List<Exception>? innerExceptions = null;

                // ReSharper disable once PossibleInvalidCastExceptionInForeachLoop
                var invocationList = action.GetInvocationList();
                var length = invocationList.Length;
                for (var index = 0; index < length; index++)
                {
                    var a = (Action<T1, T2>)invocationList[index];
                    try
                    {
                        a(arg1, arg2);
                    }
                    catch (Exception ex) when (isRedirectablePredicate == null || isRedirectablePredicate(ex))
                    {
                        if (innerExceptions == null)
                        {
                            innerExceptions = new List<Exception>();
                        }

                        innerExceptions.Add(ex);
                    }
                }

                if (innerExceptions != null)
                {
                    throw new AggregateException(innerExceptions);
                }
            }
        }

        /// <summary>
        ///     Invokes full invocation list of the specified <c>action</c> with
        ///     aggregating raised exceptions to the <see cref="AggregateException" />.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Sometimes it's important to execute full invocation list.
        ///     </para>
        /// </remarks>
        /// <typeparam name="T1">The type of the <c>action</c> argument 1.</typeparam>
        /// <typeparam name="T2">The type of the <c>action</c> argument 2.</typeparam>
        /// <typeparam name="T3">The type of the <c>action</c> argument 3.</typeparam>
        /// <param name="action">The <c>action</c> to execute.</param>
        /// <param name="arg1">The <c>action</c> argument 1.</param>
        /// <param name="arg2">The <c>action</c> argument 2.</param>
        /// <param name="arg3">The <c>action</c> argument 3.</param>
        /// <param name="isRedirectablePredicate">The predicate to determine Exception that should not be caught and aggregated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [DebuggerStepThrough]
        public static void InvokeAll<T1, T2, T3>(
            this Action<T1, T2, T3>? action,
            T1 arg1,
            T2 arg2,
            T3 arg3,
            Predicate<Exception>? isRedirectablePredicate = null)
        {
            // ReSharper disable once InvertIf
            if (action != null)
            {
                List<Exception>? innerExceptions = null;

                // ReSharper disable once PossibleInvalidCastExceptionInForeachLoop
                var invocationList = action.GetInvocationList();
                var length = invocationList.Length;
                for (var index = 0; index < length; index++)
                {
                    var a = (Action<T1, T2, T3>)invocationList[index];
                    try
                    {
                        a(arg1, arg2, arg3);
                    }
                    catch (Exception ex) when (isRedirectablePredicate == null || isRedirectablePredicate(ex))
                    {
                        if (innerExceptions == null)
                        {
                            innerExceptions = new List<Exception>();
                        }

                        innerExceptions.Add(ex);
                    }
                }

                if (innerExceptions != null)
                {
                    throw new AggregateException(innerExceptions);
                }
            }
        }

        /// <summary>
        ///     Invokes full invocation list of the specified <c>action</c> with
        ///     aggregating raised exceptions to the <see cref="AggregateException" />.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Sometimes it's important to execute full invocation list.
        ///     </para>
        /// </remarks>
        /// <typeparam name="T1">The type of the <c>action</c> argument 1.</typeparam>
        /// <typeparam name="T2">The type of the <c>action</c> argument 2.</typeparam>
        /// <typeparam name="T3">The type of the <c>action</c> argument 3.</typeparam>
        /// <typeparam name="T4">The type of the <c>action</c> argument 4.</typeparam>
        /// <param name="action">The <c>action</c> to execute.</param>
        /// <param name="arg1">The <c>action</c> argument 1.</param>
        /// <param name="arg2">The <c>action</c> argument 2.</param>
        /// <param name="arg3">The <c>action</c> argument 3.</param>
        /// <param name="arg4">The <c>action</c> argument 4.</param>
        /// <param name="isRedirectablePredicate">The predicate to determine Exception that should not be caught and aggregated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [DebuggerStepThrough]
        public static void InvokeAll<T1, T2, T3, T4>(
            this Action<T1, T2, T3, T4>? action,
            T1 arg1,
            T2 arg2,
            T3 arg3,
            T4 arg4,
            Predicate<Exception>? isRedirectablePredicate = null)
        {
            // ReSharper disable once InvertIf
            if (action != null)
            {
                List<Exception>? innerExceptions = null;

                // ReSharper disable once PossibleInvalidCastExceptionInForeachLoop
                var invocationList = action.GetInvocationList();
                var length = invocationList.Length;
                for (var index = 0; index < length; index++)
                {
                    var a = (Action<T1, T2, T3, T4>)invocationList[index];
                    try
                    {
                        a(arg1, arg2, arg3, arg4);
                    }
                    catch (Exception ex) when (isRedirectablePredicate == null || isRedirectablePredicate(ex))
                    {
                        if (innerExceptions == null)
                        {
                            innerExceptions = new List<Exception>();
                        }

                        innerExceptions.Add(ex);
                    }
                }

                if (innerExceptions != null)
                {
                    throw new AggregateException(innerExceptions);
                }
            }
        }

        /// <summary>
        ///     Invokes full invocation list of the specified <c>action</c> with
        ///     aggregating raised exceptions to the <see cref="AggregateException" />.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Sometimes it's important to execute full invocation list.
        ///     </para>
        /// </remarks>
        /// <typeparam name="T1">The type of the <c>action</c> argument 1.</typeparam>
        /// <typeparam name="T2">The type of the <c>action</c> argument 2.</typeparam>
        /// <typeparam name="T3">The type of the <c>action</c> argument 3.</typeparam>
        /// <typeparam name="T4">The type of the <c>action</c> argument 4.</typeparam>
        /// <typeparam name="T5">The type of the <c>action</c> argument 5.</typeparam>
        /// <param name="action">The <c>action</c> to execute.</param>
        /// <param name="arg1">The <c>action</c> argument 1.</param>
        /// <param name="arg2">The <c>action</c> argument 2.</param>
        /// <param name="arg3">The <c>action</c> argument 3.</param>
        /// <param name="arg4">The <c>action</c> argument 4.</param>
        /// <param name="arg5">The <c>action</c> argument 5.</param>
        /// <param name="isRedirectablePredicate">The predicate to determine Exception that should not be caught and aggregated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [DebuggerStepThrough]
        public static void InvokeAll<T1, T2, T3, T4, T5>(
            this Action<T1, T2, T3, T4, T5>? action,
            T1 arg1,
            T2 arg2,
            T3 arg3,
            T4 arg4,
            T5 arg5,
            Predicate<Exception>? isRedirectablePredicate = null)
        {
            // ReSharper disable once InvertIf
            if (action != null)
            {
                List<Exception>? innerExceptions = null;

                // ReSharper disable once PossibleInvalidCastExceptionInForeachLoop
                var invocationList = action.GetInvocationList();
                var length = invocationList.Length;
                for (var index = 0; index < length; index++)
                {
                    var a = (Action<T1, T2, T3, T4, T5>)invocationList[index];
                    try
                    {
                        a(arg1, arg2, arg3, arg4, arg5);
                    }
                    catch (Exception ex) when (isRedirectablePredicate == null || isRedirectablePredicate(ex))
                    {
                        if (innerExceptions == null)
                        {
                            innerExceptions = new List<Exception>();
                        }

                        innerExceptions.Add(ex);
                    }
                }

                if (innerExceptions != null)
                {
                    throw new AggregateException(innerExceptions);
                }
            }
        }

        /// <summary>
        ///     Invokes full invocation list of the specified <c>action</c> with
        ///     aggregating raised exceptions to the <see cref="AggregateException" />.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Sometimes it's important to execute full invocation list.
        ///     </para>
        /// </remarks>
        /// <typeparam name="T1">The type of the <c>action</c> argument 1.</typeparam>
        /// <typeparam name="T2">The type of the <c>action</c> argument 2.</typeparam>
        /// <typeparam name="T3">The type of the <c>action</c> argument 3.</typeparam>
        /// <typeparam name="T4">The type of the <c>action</c> argument 4.</typeparam>
        /// <typeparam name="T5">The type of the <c>action</c> argument 5.</typeparam>
        /// <typeparam name="T6">The type of the <c>action</c> argument 6.</typeparam>
        /// <param name="action">The <c>action</c> to execute.</param>
        /// <param name="arg1">The <c>action</c> argument 1.</param>
        /// <param name="arg2">The <c>action</c> argument 2.</param>
        /// <param name="arg3">The <c>action</c> argument 3.</param>
        /// <param name="arg4">The <c>action</c> argument 4.</param>
        /// <param name="arg5">The <c>action</c> argument 5.</param>
        /// <param name="arg6">The <c>action</c> argument 6.</param>
        /// <param name="isRedirectablePredicate">The predicate to determine Exception that should not be caught and aggregated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [DebuggerStepThrough]
        public static void InvokeAll<T1, T2, T3, T4, T5, T6>(
            this Action<T1, T2, T3, T4, T5, T6>? action,
            T1 arg1,
            T2 arg2,
            T3 arg3,
            T4 arg4,
            T5 arg5,
            T6 arg6,
            Predicate<Exception>? isRedirectablePredicate = null)
        {
            // ReSharper disable once InvertIf
            if (action != null)
            {
                List<Exception>? innerExceptions = null;

                // ReSharper disable once PossibleInvalidCastExceptionInForeachLoop
                var invocationList = action.GetInvocationList();
                var length = invocationList.Length;
                for (var index = 0; index < length; index++)
                {
                    var a = (Action<T1, T2, T3, T4, T5, T6>)invocationList[index];
                    try
                    {
                        a(arg1, arg2, arg3, arg4, arg5, arg6);
                    }
                    catch (Exception ex) when (isRedirectablePredicate == null || isRedirectablePredicate(ex))
                    {
                        if (innerExceptions == null)
                        {
                            innerExceptions = new List<Exception>();
                        }

                        innerExceptions.Add(ex);
                    }
                }

                if (innerExceptions != null)
                {
                    throw new AggregateException(innerExceptions);
                }
            }
        }

        /// <summary>
        ///     Invokes full invocation list of the specified <c>action</c> with
        ///     aggregating raised exceptions to the <see cref="AggregateException" />.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Sometimes it's important to execute full invocation list.
        ///     </para>
        /// </remarks>
        /// <typeparam name="T1">The type of the <c>action</c> argument 1.</typeparam>
        /// <typeparam name="T2">The type of the <c>action</c> argument 2.</typeparam>
        /// <typeparam name="T3">The type of the <c>action</c> argument 3.</typeparam>
        /// <typeparam name="T4">The type of the <c>action</c> argument 4.</typeparam>
        /// <typeparam name="T5">The type of the <c>action</c> argument 5.</typeparam>
        /// <typeparam name="T6">The type of the <c>action</c> argument 6.</typeparam>
        /// <typeparam name="T7">The type of the <c>action</c> argument 7.</typeparam>
        /// <param name="action">The <c>action</c> to execute.</param>
        /// <param name="arg1">The <c>action</c> argument 1.</param>
        /// <param name="arg2">The <c>action</c> argument 2.</param>
        /// <param name="arg3">The <c>action</c> argument 3.</param>
        /// <param name="arg4">The <c>action</c> argument 4.</param>
        /// <param name="arg5">The <c>action</c> argument 5.</param>
        /// <param name="arg6">The <c>action</c> argument 6.</param>
        /// <param name="arg7">The <c>action</c> argument 7.</param>
        /// <param name="isRedirectablePredicate">The predicate to determine Exception that should not be caught and aggregated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [DebuggerStepThrough]
        public static void InvokeAll<T1, T2, T3, T4, T5, T6, T7>(
            this Action<T1, T2, T3, T4, T5, T6, T7>? action,
            T1 arg1,
            T2 arg2,
            T3 arg3,
            T4 arg4,
            T5 arg5,
            T6 arg6,
            T7 arg7,
            Predicate<Exception>? isRedirectablePredicate = null)
        {
            // ReSharper disable once InvertIf
            if (action != null)
            {
                List<Exception>? innerExceptions = null;

                // ReSharper disable once PossibleInvalidCastExceptionInForeachLoop
                var invocationList = action.GetInvocationList();
                var length = invocationList.Length;
                for (var index = 0; index < length; index++)
                {
                    var a = (Action<T1, T2, T3, T4, T5, T6, T7>)invocationList[index];
                    try
                    {
                        a(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                    }
                    catch (Exception ex) when (isRedirectablePredicate == null || isRedirectablePredicate(ex))
                    {
                        if (innerExceptions == null)
                        {
                            innerExceptions = new List<Exception>();
                        }

                        innerExceptions.Add(ex);
                    }
                }

                if (innerExceptions != null)
                {
                    throw new AggregateException(innerExceptions);
                }
            }
        }

        /// <summary>
        ///     Invokes full invocation list of the specified <c>action</c> with
        ///     aggregating raised exceptions to the <see cref="AggregateException" />.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Sometimes it's important to execute full invocation list.
        ///     </para>
        /// </remarks>
        /// <typeparam name="T1">The type of the <c>action</c> argument 1.</typeparam>
        /// <typeparam name="T2">The type of the <c>action</c> argument 2.</typeparam>
        /// <typeparam name="T3">The type of the <c>action</c> argument 3.</typeparam>
        /// <typeparam name="T4">The type of the <c>action</c> argument 4.</typeparam>
        /// <typeparam name="T5">The type of the <c>action</c> argument 5.</typeparam>
        /// <typeparam name="T6">The type of the <c>action</c> argument 6.</typeparam>
        /// <typeparam name="T7">The type of the <c>action</c> argument 7.</typeparam>
        /// <typeparam name="T8">The type of the <c>action</c> argument 8.</typeparam>
        /// <param name="action">The <c>action</c> to execute.</param>
        /// <param name="arg1">The <c>action</c> argument 1.</param>
        /// <param name="arg2">The <c>action</c> argument 2.</param>
        /// <param name="arg3">The <c>action</c> argument 3.</param>
        /// <param name="arg4">The <c>action</c> argument 4.</param>
        /// <param name="arg5">The <c>action</c> argument 5.</param>
        /// <param name="arg6">The <c>action</c> argument 6.</param>
        /// <param name="arg7">The <c>action</c> argument 7.</param>
        /// <param name="arg8">The <c>action</c> argument 8.</param>
        /// <param name="isRedirectablePredicate">The predicate to determine Exception that should not be caught and aggregated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [DebuggerStepThrough]
        public static void InvokeAll<T1, T2, T3, T4, T5, T6, T7, T8>(
            this Action<T1, T2, T3, T4, T5, T6, T7, T8>? action,
            T1 arg1,
            T2 arg2,
            T3 arg3,
            T4 arg4,
            T5 arg5,
            T6 arg6,
            T7 arg7,
            T8 arg8,
            Predicate<Exception>? isRedirectablePredicate = null)
        {
            // ReSharper disable once InvertIf
            if (action != null)
            {
                List<Exception>? innerExceptions = null;

                // ReSharper disable once PossibleInvalidCastExceptionInForeachLoop
                var invocationList = action.GetInvocationList();
                var length = invocationList.Length;
                for (var index = 0; index < length; index++)
                {
                    var a = (Action<T1, T2, T3, T4, T5, T6, T7, T8>)invocationList[index];
                    try
                    {
                        a(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                    }
                    catch (Exception ex) when (isRedirectablePredicate == null || isRedirectablePredicate(ex))
                    {
                        if (innerExceptions == null)
                        {
                            innerExceptions = new List<Exception>();
                        }

                        innerExceptions.Add(ex);
                    }
                }

                if (innerExceptions != null)
                {
                    throw new AggregateException(innerExceptions);
                }
            }
        }
    }
}
